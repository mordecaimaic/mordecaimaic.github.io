---
title: (长期持续更新)cs61a入门算法记录
author: mordecaimaic
date: 2023-11-19 12:30:00 +0800
categories: [CS自学, cs61a]
tags: [cs61a]     # TAG names should always be lowercase
---

# CS61a入门算法记录
本文长期记录一些，我认为在cs61a中让我耳目一新的算法

## week1

## week2

## week3

## week4

## week5
### count_stair_ways    
- 这个算法要求是，如果有n个台阶，每次可以走一步或者两步，那么要求出多少种走法
```python
    def count_stair_ways(n):
    """Returns the number of ways to climb up a flight of
    n stairs, moving either one step or two steps at a time.
    >>> count_stair_ways(1)
    1
    >>> count_stair_ways(2)
    2
    >>> count_stair_ways(4)
    5
    """
    "*** YOUR CODE HERE ***"
    if n == 1:
        return 1
    elif n == 2:
        return 2
    else:
        return count_stair_ways(n - 1) + count_stair_ways(n - 2)
```
### count_k
- 这个算法要求是上面的算法的进阶，假设n是台阶的数量，k是每次可以走的最大步数，那么要求计算出有多少种走法。
```
def count_k(n, k):
    """Counts the number of paths up a flight of n stairs
    when taking up to k steps at a time.
    >>> count_k(3, 3) # 3, 2 + 1, 1 + 2, 1 + 1 + 1
    4
    >>> count_k(4, 4)
    8
    >>> count_k(10, 3)
    274
    >>> count_k(300, 1) # Only one step at a time
    1
    """
    "*** YOUR CODE HERE ***"
    if n == 0:
        return 1
    elif n < 0:
        return 0
    else:
        total = 0
        for i in range(1, k + 1):
            total += count_k(n - i, k)
        return total
```
#### count_k解析
这个函数的目标是计算爬上一个有 `n` 阶的楼梯有多少种方法，如果你一次可以爬 `1` 到 `k` 阶。这个函数的工作方式是使用了一种叫做递归的技术。以下是这个函数的详细解释：

1. **函数定义**：`def count_k(n, k):` 这一行定义了函数的名字（`count_k`）和它接受的两个参数（`n` 和 `k`）。`n` 是楼梯的阶数，`k` 是你一次可以爬的最大阶数。

2. **基本情况**：`if n == 0:` 和 `elif n < 0:` 这两行处理了两种基本情况。如果 `n` 等于 `0`，那么说明你已经到达了楼顶，所以有 `1` 种方法可以到达（也就是不需要再爬）。如果 `n` 小于 `0`，那么说明你试图一次爬过多的阶数，这是不可能的，所以有 `0` 种方法可以到达。

3. **递归调用**：`for i in range(1, k + 1):` 这一行开始了一个循环，对于每一个 `i`（从 `1` 到 `k`），我们都计算有多少种方法可以爬上剩下的 `n - i` 阶。这是通过递归调用 `count_k(n - i, k)` 来实现的。

4. **计算总的方法数**：`total += count_k(n - i, k)` 这一行把每一种可能的爬法的方法数加到 `total` 上。这样，`total` 就会包含所有可能的爬法的方法数。

5. **返回结果**：`return total` 这一行返回了总的方法数。这就是这个函数的结果。

这个函数的关键在于理解递归的思想。我们从一个大问题开始，然后将其分解成更小的问题，然后解决这些小问题。这就是这个函数的基本思想。

#### count_k例子
让我们来看看 `count_k(3, 3)` 是如何工作的。

首先，我们要计算爬上3阶楼梯有多少种方法，如果我们一次可以爬1、2或3阶。

1. 我们首先考虑一次爬1阶的情况。如果我们首先爬1阶，那么我们需要计算爬上剩下的2阶楼梯有多少种方法。这就变成了一个新的问题 `count_k(2, 3)`。

2. 然后，我们考虑一次爬2阶的情况。如果我们首先爬2阶，那么我们需要计算爬上剩下的1阶楼梯有多少种方法。这就变成了一个新的问题 `count_k(1, 3)`。

3. 最后，我们考虑一次爬3阶的情况。如果我们首先爬3阶，那么我们已经到达了楼顶，所以这种情况下有1种方法。

4. 我们把所有这些方法加起来，就得到了总的方法数。所以，`count_k(3, 3)` 的结果是 `count_k(2, 3) + count_k(1, 3) + 1`。

5. 而 `count_k(2, 3)` 的结果是 `count_k(1, 3) + count_k(0, 3) + count(-1, 3)`。

6. 按照此种方法以此类推，得到最终的答案。

这就是 `count_k(3, 3)` 的工作原理。这个函数的关键在于理解递归的思想。我们从一个大问题开始，然后将其分解成更小的问题，然后解决这些小问题。这就是这个函数的基本思想。

![count_k](/assets/images/cs61a/count_k_light.svg "count_k"){: .light}
![count_k](/assets/images/cs61a/count_k_dark.drawio.svg "count_k"){: .dark}

如果学习过cs50的话，在tideman这个作业里面，应该就使用过这种方法，递归+for循环迭代。